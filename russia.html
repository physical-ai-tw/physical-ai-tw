<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>俄羅斯方塊遊戲</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
    }
    canvas {
      border: 2px solid #000;
      background-color: #fff;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="300" height="600"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const ROWS = 20; // 遊戲區域的行數
    const COLS = 10; // 遊戲區域的列數
    const BLOCK_SIZE = 30; // 每個方塊的大小
    const EMPTY_COLOR = '#fff'; // 空格顏色
    const BORDER_COLOR = '#000'; // 邊框顏色

    // 定義方塊形狀
    const SHAPES = [
      [[1, 1, 1, 1]], // I 形
      [[1, 1], [1, 1]], // O 形
      [[0, 1, 0], [1, 1, 1]], // T 形
      [[1, 1, 0], [0, 1, 1]], // S 形
      [[0, 1, 1], [1, 1, 0]], // Z 形
      [[1, 1, 1], [1, 0, 0]], // L 形
      [[1, 1, 1], [0, 0, 1]]  // J 形
    ];

    const COLORS = ['cyan', 'yellow', 'purple', 'green', 'red', 'orange', 'blue'];

    let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0)); // 初始化遊戲區域
    let currentShape = getRandomShape(); // 當前方塊
    let currentX = 3; // 當前方塊的 X 座標
    let currentY = 0; // 當前方塊的 Y 座標
    let gameOver = false;

    // 遊戲主循環
    function gameLoop() {
      if (gameOver) {
        ctx.fillStyle = 'red';
        ctx.font = '20px Arial';
        ctx.fillText('遊戲結束！按 F5 重玩', canvas.width / 4, canvas.height / 2);
        return;
      }

      moveDown();
      drawBoard();
    }

    // 繪製遊戲區域
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 繪製遊戲區域
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          drawBlock(col, row, board[row][col] ? COLORS[board[row][col] - 1] : EMPTY_COLOR);
        }
      }

      // 繪製當前方塊
      currentShape.shape.forEach((row, y) => {
        row.forEach((cell, x) => {
          if (cell) {
            drawBlock(currentX + x, currentY + y, COLORS[currentShape.color]);
          }
        });
      });
    }

    // 繪製單個方塊
    function drawBlock(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      ctx.strokeStyle = BORDER_COLOR;
      ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    }

    // 隨機生成方塊
    function getRandomShape() {
      const index = Math.floor(Math.random() * SHAPES.length);
      return { shape: SHAPES[index], color: index };
    }

    // 方塊下移
    function moveDown() {
      if (!canMove(currentX, currentY + 1, currentShape.shape)) {
        // 無法下移，將方塊固定到遊戲區域
        currentShape.shape.forEach((row, y) => {
          row.forEach((cell, x) => {
            if (cell) {
              board[currentY + y][currentX + x] = currentShape.color + 1;
            }
          });
        });

        // 檢查是否有完整的行
        clearLines();

        // 生成新方塊
        currentShape = getRandomShape();
        currentX = 3;
        currentY = 0;

        // 檢查遊戲是否結束
        if (!canMove(currentX, currentY, currentShape.shape)) {
          gameOver = true;
        }
      } else {
        currentY++;
      }
    }

    // 檢查是否可以移動
    function canMove(x, y, shape) {
      return shape.every((row, dy) =>
        row.every((cell, dx) => {
          const newX = x + dx;
          const newY = y + dy;
          return (
            !cell ||
            (newX >= 0 && newX < COLS && newY >= 0 && newY < ROWS && !board[newY][newX])
          );
        })
      );
    }

    // 清除完整的行
    function clearLines() {
      board = board.filter(row => row.some(cell => !cell));
      while (board.length < ROWS) {
        board.unshift(Array(COLS).fill(0));
      }
    }

    // 處理鍵盤輸入
    document.addEventListener('keydown', event => {
      switch (event.key) {
        case 'ArrowLeft':
          if (canMove(currentX - 1, currentY, currentShape.shape)) currentX--;
          break;
        case 'ArrowRight':
          if (canMove(currentX + 1, currentY, currentShape.shape)) currentX++;
          break;
        case 'ArrowDown':
          moveDown();
          break;
        case 'ArrowUp':
          const rotated = rotate(currentShape.shape);
          if (canMove(currentX, currentY, rotated)) currentShape.shape = rotated;
          break;
      }
      drawBoard();
    });

    // 旋轉方塊
    function rotate(shape) {
      return shape[0].map((_, i) => shape.map(row => row[i]).reverse());
    }

    // 啟動遊戲
    setInterval(gameLoop, 500);
  </script>
</body>
</html>