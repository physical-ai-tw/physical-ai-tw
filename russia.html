<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>俄羅斯方塊</title>
  <style>
    body {
      margin: 0;
      background-color: #f0f0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: Arial, sans-serif;
      user-select: none;
      touch-action: manipulation;
    }
    #gameCanvas {
      border: 2px solid #000;
      background-color: #fff;
    }
    #startButton {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      padding: 16px 32px;
      font-size: 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 10px;
      z-index: 10;
    }
    .controls {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .controls-row {
      display: flex;
      gap: 20px;
      margin: 5px;
    }
    .control-btn {
      padding: 20px;
      font-size: 20px;
      border-radius: 10px;
      background-color: #2196F3;
      color: white;
      border: none;
      min-width: 60px;
    }
  </style>
</head>
<body>
  <button id="startButton">開始遊戲</button>
  <canvas id="gameCanvas" width="300" height="600"></canvas>

  <div class="controls">
    <div class="controls-row">
      <button class="control-btn" id="rotateBtn">↻</button>
    </div>
    <div class="controls-row">
      <button class="control-btn" id="leftBtn">←</button>
      <button class="control-btn" id="downBtn">↓</button>
      <button class="control-btn" id="rightBtn">→</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startButton = document.getElementById('startButton');

    const ROWS = 20, COLS = 10, BLOCK_SIZE = 30;
    const EMPTY_COLOR = '#fff', BORDER_COLOR = '#000';

    const SHAPES = [
      [[1, 1, 1, 1]], // I
      [[1, 1], [1, 1]], // O
      [[0, 1, 0], [1, 1, 1]], // T
      [[1, 1, 0], [0, 1, 1]], // S
      [[0, 1, 1], [1, 1, 0]], // Z
      [[1, 1, 1], [1, 0, 0]], // L
      [[1, 1, 1], [0, 0, 1]]  // J
    ];
    const COLORS = ['cyan', 'yellow', 'purple', 'green', 'red', 'orange', 'blue'];

    let board = [];
    let currentShape = null;
    let currentX = 0, currentY = 0;
    let gameOver = false;
    let intervalId;

    function initGame() {
      board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
      gameOver = false;
      currentShape = getRandomShape();
      currentX = 3;
      currentY = 0;
      if (intervalId) clearInterval(intervalId);
      intervalId = setInterval(gameLoop, 500);
      drawBoard();
    }

    function getRandomShape() {
      const index = Math.floor(Math.random() * SHAPES.length);
      return { shape: SHAPES[index], color: index };
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          drawBlock(col, row, board[row][col] ? COLORS[board[row][col] - 1] : EMPTY_COLOR);
        }
      }

      currentShape.shape.forEach((row, y) => {
        row.forEach((cell, x) => {
          if (cell) {
            drawBlock(currentX + x, currentY + y, COLORS[currentShape.color]);
          }
        });
      });
    }

    function drawBlock(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      ctx.strokeStyle = BORDER_COLOR;
      ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    }

    function canMove(x, y, shape) {
      return shape.every((row, dy) =>
        row.every((cell, dx) => {
          const newX = x + dx, newY = y + dy;
          return (
            !cell ||
            (newX >= 0 && newX < COLS && newY >= 0 && newY < ROWS && !board[newY][newX])
          );
        })
      );
    }

    function moveDown() {
      if (!canMove(currentX, currentY + 1, currentShape.shape)) {
        currentShape.shape.forEach((row, y) => {
          row.forEach((cell, x) => {
            if (cell) board[currentY + y][currentX + x] = currentShape.color + 1;
          });
        });
        clearLines();
        currentShape = getRandomShape();
        currentX = 3; currentY = 0;
        if (!canMove(currentX, currentY, currentShape.shape)) {
          gameOver = true;
          clearInterval(intervalId);
          startButton.style.display = 'block';
          alert('遊戲結束！');
        }
      } else {
        currentY++;
      }
      drawBoard();
    }

    function clearLines() {
      board = board.filter(row => row.some(cell => !cell));
      while (board.length < ROWS) board.unshift(Array(COLS).fill(0));
    }

    function rotate(shape) {
      return shape[0].map((_, i) => shape.map(row => row[i]).reverse());
    }

    function gameLoop() {
      if (!gameOver) moveDown();
    }

    // 鍵盤控制
    document.addEventListener('keydown', e => {
      if (gameOver) return;
      switch (e.key) {
        case 'ArrowLeft':
          if (canMove(currentX - 1, currentY, currentShape.shape)) currentX--;
          break;
        case 'ArrowRight':
          if (canMove(currentX + 1, currentY, currentShape.shape)) currentX++;
          break;
        case 'ArrowDown':
          moveDown();
          break;
        case 'ArrowUp':
          const rotated = rotate(currentShape.shape);
          if (canMove(currentX, currentY, rotated)) currentShape.shape = rotated;
          break;
      }
      drawBoard();
    });

    // 手機按鈕控制
    document.getElementById('leftBtn').onclick = () => {
      if (canMove(currentX - 1, currentY, currentShape.shape)) currentX--;
      drawBoard();
    };
    document.getElementById('rightBtn').onclick = () => {
      if (canMove(currentX + 1, currentY, currentShape.shape)) currentX++;
      drawBoard();
    };
    document.getElementById('downBtn').onclick = () => {
      moveDown();
    };
    document.getElementById('rotateBtn').onclick = () => {
      const rotated = rotate(currentShape.shape);
      if (canMove(currentX, currentY, rotated)) currentShape.shape = rotated;
      drawBoard();
    };

    // 開始遊戲按鈕
    startButton.addEventListener('click', () => {
      startButton.style.display = 'none';
      initGame();
    });
  </script>
</body>
</html>
