<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32-C3 遙控器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .joystick-container {
            width: 200px;
            height: 200px;
            background-color: #d1d5db;
            border-radius: 50%;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
            touch-action: none;
        }
        .joystick-handle {
            width: 80px;
            height: 80px;
            background: linear-gradient(145deg, #1d4ed8, #3b82f6);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.08);
            border: 2px solid #60a5fa;
            cursor: grab;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">
    <div class="container mx-auto p-4 md:p-8 max-w-xl">
        <!-- 主面板 -->
        <div class="bg-white rounded-3xl shadow-xl p-6 md:p-10 text-center space-y-8">
            <h1 class="text-3xl md:text-4xl font-extrabold text-gray-800">虛擬遙控器</h1>
            <p class="text-gray-600 text-lg">透過 Wi-Fi 控制您的無人車</p>
            <label class="text-sm text-gray-600">IP 位址:
                <input id="esp32Ip" type="text" value="car-esp32c3.local" class="border rounded px-2 py-1 ml-2 w-40 text-sm">
            </label>                      

            <!-- 遙控搖桿區域 -->
            <div class="flex flex-col md:flex-row items-center justify-center space-y-8 md:space-y-0 md:space-x-12">
                <!-- 左搖桿 (轉向) -->
                <div class="flex flex-col items-center space-y-4">
                    <label for="joystickLeft" class="text-xl font-bold text-gray-700">轉向 (Steer)</label>
                    <div id="joystickLeft" class="joystick-container">
                        <div id="joystickHandleLeft" class="joystick-handle"></div>
                    </div>
                    <div class="text-sm text-gray-500">X: <span id="xValueLeft">0</span>, Y: <span id="yValueLeft">0</span></div>
                </div>

                <!-- 右搖桿 (油門) -->
                <div class="flex flex-col items-center space-y-4">
                    <label for="joystickRight" class="text-xl font-bold text-gray-700">油門 (Throttle)</label>
                    <div id="joystickRight" class="joystick-container">
                        <div id="joystickHandleRight" class="joystick-handle"></div>
                    </div>
                    <div class="text-sm text-gray-500">X: <span id="xValueRight">0</span>, Y: <span id="yValueRight">0</span></div>
                </div>
            </div>

            <!-- 控制資訊與狀態 -->
            <div class="mt-8 space-y-4">
                <div class="bg-blue-100 border border-blue-400 text-blue-700 px-4 py-3 rounded-lg" role="alert">
                    <p class="font-bold">狀態資訊</p>
                    <p>正在發送指令: <span id="statusMessage" class="font-semibold">等待操作...</span></p>
                </div>
            </div>
        </div>
    </div>

    <!-- 只顯示 <script> 內容（整個 HTML 可保留你原本的樣式/結構） -->
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const esp32IpInput = document.getElementById('esp32Ip');
        let esp32Ip = esp32IpInput.value;
    
        // WebSocket
        let ws = null;
        let wsUrl = null;
        let wsConnectedElem = null;
        wsConnectedElem = document.getElementById('statusMessage');
    
        function connectWS() {
            esp32Ip = esp32IpInput.value.trim();
            if (!esp32Ip) return;
    
            // 用 port 81 為 WebSocket server（ESP 程式使用 81）
            wsUrl = `ws://${esp32Ip}:81/`;
            if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
                // already connecting/open
                return;
            }
            console.log("Connecting to", wsUrl);
            ws = new WebSocket(wsUrl);
    
            ws.onopen = () => {
                console.log("WebSocket open");
                wsConnectedElem.textContent = `WebSocket connected to ${esp32Ip}`;
            };
            ws.onclose = () => {
                console.log("WebSocket closed, retry in 1s");
                wsConnectedElem.textContent = 'WebSocket disconnected, retrying...';
                setTimeout(connectWS, 1000);
            };
            ws.onerror = (err) => {
                console.warn("WebSocket error", err);
                wsConnectedElem.textContent = 'WebSocket error';
                // socket will fire close as well; let reconnect logic handle it
            };
            ws.onmessage = (evt) => {
                // 如果需要從 ESP 回傳狀態可在這裡處理
                console.log("WS msg:", evt.data);
            };
        }
    
        // 呼叫 connect 一次，並在 IP 改變時重連
        connectWS();
        esp32IpInput.addEventListener('change', () => {
            if (ws) {
                try { ws.close(); } catch(e) {}
                ws = null;
            }
            connectWS();
        });
    
        // joystick setup (與你原本相同，只是 onMoveCallback 儲存變數)
        function setupJoystick(containerId, handleId, xValueId, yValueId, onMoveCallback) {
            const container = document.getElementById(containerId);
            const handle = document.getElementById(handleId);
            const xValueSpan = document.getElementById(xValueId);
            const yValueSpan = document.getElementById(yValueId);
            
            let isDragging = false;
    
            function calcCenter() {
                const containerRect = container.getBoundingClientRect();
                return {
                    cx: containerRect.left + container.offsetWidth / 2,
                    cy: containerRect.top + container.offsetHeight / 2,
                    maxR: (container.offsetWidth / 2) - (handle.offsetWidth / 2),
                    width: container.offsetWidth,
                    height: container.offsetHeight
                };
            }
    
            const getPosition = (event) => {
                const p = calcCenter();
                const clientX = event.touches ? event.touches[0].clientX : event.clientX;
                const clientY = event.touches ? event.touches[0].clientY : event.clientY;
                let dx = clientX - p.cx;
                let dy = clientY - p.cy;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > p.maxR) {
                    dx *= p.maxR / distance;
                    dy *= p.maxR / distance;
                }
                handle.style.left = `${50 + (dx / p.width) * 100}%`;
                handle.style.top  = `${50 + (dy / p.height) * 100}%`;
    
                const x = Math.round((dx / p.maxR) * 100);
                const y = -Math.round((dy / p.maxR) * 100); // Y up positive
    
                xValueSpan.textContent = x;
                yValueSpan.textContent = y;
                onMoveCallback(x, y);
            };
    
            const stopDragging = () => {
                isDragging = false;
                handle.style.left = '50%';
                handle.style.top = '50%';
                xValueSpan.textContent = '0';
                yValueSpan.textContent = '0';
                onMoveCallback(0, 0);
            };
    
            handle.addEventListener('mousedown', (e) => { isDragging = true; e.preventDefault(); });
            container.addEventListener('touchstart', (e) => { isDragging = true; e.preventDefault(); });
    
            document.addEventListener('mousemove', (e) => { if (isDragging) getPosition(e); });
            document.addEventListener('touchmove', (e) => { if (isDragging) getPosition(e); });
    
            document.addEventListener('mouseup', stopDragging);
            document.addEventListener('touchend', stopDragging);
        }
    
        let steerValue = 0;
        let throttleValue = 0;
    
        setupJoystick('joystickLeft', 'joystickHandleLeft', 'xValueLeft', 'yValueLeft', (x, y) => { steerValue = x; });
        setupJoystick('joystickRight','joystickHandleRight','xValueRight','yValueRight',(x, y) => { throttleValue = y; });
    
        // 定時推送到 WebSocket（50ms => 20Hz）
        setInterval(() => {
            // 若 IP 有變動，快速重連（簡單策略）
            const newIp = esp32IpInput.value.trim();
            if (newIp !== esp32Ip) {
                esp32Ip = newIp;
                if (ws) { try { ws.close(); } catch(e) {} ws = null; }
                connectWS();
            }
    
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
    
            // send only when有變動 或 若需持續發送也可以不檢查
            const payload = JSON.stringify({ steer: steerValue, throttle: throttleValue });
            ws.send(payload);
            // 更新狀態區塊
            document.getElementById('statusMessage').textContent = `Sent: ${payload}`;
        }, 50);
    });
    </script>
    
    <script>
/*        
        // JavaScript for joystick logic and sending data to ESP32
        document.addEventListener('DOMContentLoaded', () => {
            //const esp32Ip = document.getElementById('esp32Ip').textContent; // ESP32 IP 位址
            const esp32IpInput = document.getElementById('esp32Ip');
            let esp32Ip = esp32IpInput.value;

            // 處理搖桿邏輯的函式
            function setupJoystick(containerId, handleId, xValueId, yValueId, onMoveCallback) {
                const container = document.getElementById(containerId);
                const handle = document.getElementById(handleId);
                const xValueSpan = document.getElementById(xValueId);
                const yValueSpan = document.getElementById(yValueId);
                
                let isDragging = false;
                const containerRect = container.getBoundingClientRect();
                const containerCenterX = containerRect.left + container.offsetWidth / 2;
                const containerCenterY = containerRect.top + container.offsetHeight / 2;
                const maxRadius = (container.offsetWidth / 2) - (handle.offsetWidth / 2);

                const getPosition = (event) => {
                    // 根據是觸控或滑鼠事件來取得座標
                    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
                    const clientY = event.touches ? event.touches[0].clientY : event.clientY;
                    
                    let dx = clientX - containerCenterX;
                    let dy = clientY - containerCenterY;

                    // 限制搖桿在圓形容器內
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > maxRadius) {
                        dx *= maxRadius / distance;
                        dy *= maxRadius / distance;
                    }

                    // 更新搖桿位置
                    handle.style.left = `${50 + (dx / container.offsetWidth) * 100}%`;
                    handle.style.top = `${50 + (dy / container.offsetHeight) * 100}%`;

                    // 映射數值到 -100 到 100
                    const x = Math.round((dx / maxRadius) * 100);
                    const y = -Math.round((dy / maxRadius) * 100); // 讓 Y 軸向上為正

                    xValueSpan.textContent = x;
                    yValueSpan.textContent = y;

                    onMoveCallback(x, y);
                };

                const stopDragging = () => {
                    isDragging = false;
                    handle.style.left = '50%';
                    handle.style.top = '50%';
                    xValueSpan.textContent = '0';
                    yValueSpan.textContent = '0';
                    onMoveCallback(0, 0); // 鬆開時傳送歸零指令
                };

                handle.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    e.preventDefault();
                });

                container.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        getPosition(e);
                    }
                });

                document.addEventListener('touchmove', (e) => {
                    if (isDragging) {
                        getPosition(e);
                    }
                });

                document.addEventListener('mouseup', stopDragging);
                document.addEventListener('touchend', stopDragging);
            }

            // 傳送 HTTP GET 請求到 ESP32
            const sendCommand = (steer, throttle) => {
                if (steer === 0 && throttle === 0) {
                   return; // 如果兩個值都是 0，就不送出指令
                }
                
                const statusMessage = document.getElementById('statusMessage');
                const url = `http://${esp32Ip}/control?steer=${steer}&throttle=${throttle}`;
                
                // 使用 fetch API 傳送指令
                fetch(url, { method: 'GET' })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        statusMessage.textContent = `成功發送指令: 轉向=${steer}, 油門=${throttle}`;
                    })
                    .catch(error => {
                        console.error('指令發送失敗:', error);
                        statusMessage.textContent = '指令發送失敗，請檢查連線。';
                    });
            };

            // 監聽搖桿移動並傳送指令
            let steerValue = 0;
            let throttleValue = 0;

            setupJoystick('joystickLeft', 'joystickHandleLeft', 'xValueLeft', 'yValueLeft', (x, y) => {
                steerValue = x;
            });

            setupJoystick('joystickRight', 'joystickHandleRight', 'xValueRight', 'yValueRight', (x, y) => {
                throttleValue = y;
            });

            // 以固定頻率傳送指令，避免過度頻繁的請求
            setInterval(() => {
                esp32Ip = esp32IpInput.value; // 每次送出都抓最新 IP
                sendCommand(steerValue, throttleValue);
            }, 100);
        });
*/
    </script>
</body>
</html>
